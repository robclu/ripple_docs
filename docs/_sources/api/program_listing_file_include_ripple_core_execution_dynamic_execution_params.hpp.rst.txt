
.. _program_listing_file_include_ripple_core_execution_dynamic_execution_params.hpp:

Program Listing for File dynamic_execution_params.hpp
=====================================================

|exhale_lsh| :ref:`Return to documentation for file <file_include_ripple_core_execution_dynamic_execution_params.hpp>` (``include/ripple/core/execution/dynamic_execution_params.hpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   //==--- ripple/core/execution/dynamic_execution_params.hpp - -*- C++ -*- ---==//
   //
   //                                Ripple
   //
   //                      Copyright (c) 2019, 2020 Rob Clucas.
   //
   //  This file is distributed under the MIT License. See LICENSE for details.
   //
   //==------------------------------------------------------------------------==//
   //
   //
   //==------------------------------------------------------------------------==//
   
   #ifndef RIPPLE_EXECUTION_DYNAMIC_EXECUTION_PARAMS_HPP
   #define RIPPLE_EXECUTION_DYNAMIC_EXECUTION_PARAMS_HPP
   
   #include "execution_params.hpp"
   #include <ripple/core/iterator/block_iterator.hpp>
   #include <ripple/core/multidim/dynamic_multidim_space.hpp>
   #include <ripple/core/storage/storage_traits.hpp>
   
   namespace ripple {
   
   template <typename Shared>
   struct DynamicExecParams : public ExecParams<DynamicExecParams<Shared>> {
    private:
     /*==--- [aliases] --------------------------------------------------------==*/
   
     // clang-format off
     using Traits    = layout_traits_t<Shared>;
     using Value     = typename Traits::Value;
     using Allocator = typename Traits::Allocator;
     using Space     = DynamicMultidimSpace<3>;
     using Step      = typename Space::Step;
   
     template <size_t Dims>
     using MakeSpaceType = DynamicMultidimSpace<Dims>;
     // clang-format on
   
    public:
     /*==--- [constructor] ----------------------------------------------------==*/
   
     ripple_host_device constexpr DynamicExecParams() noexcept
     : space_{1024, 1, 1} {}
   
     template <typename... Sizes, all_arithmetic_size_enable_t<3, Sizes...> = 0>
     ripple_host_device constexpr DynamicExecParams(Sizes&&... sizes) noexcept
     : space_{static_cast<Step>(sizes)...} {}
   
     template <typename... Sizes, all_arithmetic_size_enable_t<3, Sizes...> = 0>
     ripple_host_device constexpr DynamicExecParams(
       uint32_t padding, Sizes&&... sizes) noexcept
     : space_{padding, static_cast<Step>(sizes)...} {}
   
     /*==--- [size] -----------------------------------------------------------==*/
   
     template <size_t Dims>
     ripple_host_device constexpr auto size() const noexcept -> Step {
       static_assert(
         Dims <= 3, "Execution space can't be more than 3 dimensions!");
       Step total_size = space_.size(dimx());
       unrolled_for<Dims - 1>([&](auto d) {
         constexpr auto dim = d + 1;
         total_size *= space_.size(dim);
       });
       return total_size;
     }
   
     template <size_t Dims>
     ripple_host_device constexpr auto
     size(size_t padding) const noexcept -> Step {
       static_assert(
         Dims <= 3, "Execution space can't be more than 3 dimensions!");
       const size_t pad        = padding * 2;
       Step         total_size = space_.internal_size(dimx()) + pad;
       unrolled_for<Dims - 1>([&](auto d) {
         constexpr auto dim = d + 1;
         total_size *= space_.internal_size(dim) + pad;
       });
       return total_size;
     }
   
     template <typename Dim>
     ripple_host_device constexpr auto size(Dim&& dim) const noexcept -> size_t {
       return space_.internal_size(static_cast<Dim&&>(dim));
     }
   
     /*==--- [properties] -----------------------------------------------------==*/
   
     ripple_host_device constexpr auto padding() const noexcept -> size_t {
       return space_.padding();
     }
   
     /*==--- [creation] -------------------------------------------------------==*/
   
     template <size_t Dims, typename T>
     ripple_host_device auto iterator(T* data) const noexcept
       -> BlockIterator<Value, MakeSpaceType<Dims>> {
       using SpaceType = MakeSpaceType<Dims>;
       using Iter      = BlockIterator<Value, SpaceType>;
       SpaceType space;
       unrolled_for<Dims>([&](auto d) {
         constexpr auto dim = d;
         space[dim]         = space_[dim];
       });
       space.padding() = space_.padding();
       return Iter{Allocator::create(data, space), space};
     }
   
     template <size_t Dims>
     ripple_host_device constexpr auto allocation_size() const noexcept -> size_t {
       return Allocator::allocation_size(size<Dims>());
     }
   
    private:
     Space space_; 
   };
   
   /*==--- [functions] --------------------------------------------------------==*/
   
   template <size_t Dims, typename Shared = VoidShared>
   ripple_host_device auto
   dynamic_params(size_t padding = 0) noexcept -> DynamicExecParams<Shared> {
     constexpr auto size_x = (Dims == 1 ? 512 : Dims == 2 ? 32 : 8);
     constexpr auto size_y = (Dims == 1 ? 1 : Dims == 2 ? 16 : 8);
     constexpr auto size_z = (Dims == 1 ? 1 : Dims == 2 ? 1 : 8);
   
     return DynamicExecParams<Shared>(padding, size_x, size_y, size_z);
   }
   
   } // namespace ripple
   
   #endif // RIPPLE_EXECUTION_DYNAMIC_EXECUTION_PARAMS_HPP
